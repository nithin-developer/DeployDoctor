"""
GitHub Service for PR creation, CI monitoring, and auto-merge.
Handles the complete PR workflow after AI agent pushes fixes.
"""

import asyncio
import re
import time
from typing import Optional, Dict, Any, Tuple
from dataclasses import dataclass
from enum import Enum

import httpx

from config.settings import get_settings

settings = get_settings()


class CIStatus(str, Enum):
    """CI workflow status."""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    SUCCESS = "success"
    FAILURE = "failure"
    TIMEOUT = "timeout"
    ERROR = "error"


@dataclass
class PRResult:
    """Result of PR creation."""
    success: bool
    pr_number: Optional[int] = None
    pr_url: Optional[str] = None
    error: Optional[str] = None


@dataclass
class CIResult:
    """Result of CI monitoring."""
    status: CIStatus
    conclusion: Optional[str] = None
    run_url: Optional[str] = None
    error: Optional[str] = None


@dataclass
class WorkflowResult:
    """Complete workflow result (PR + CI + Merge)."""
    pr_created: bool
    pr_url: Optional[str] = None
    pr_number: Optional[int] = None
    ci_status: CIStatus = CIStatus.PENDING
    ci_url: Optional[str] = None
    merged: bool = False
    error: Optional[str] = None


class GitHubService:
    """Service for interacting with GitHub API."""
    
    def __init__(self, token: Optional[str] = None):
        self.token = token or settings.GITHUB_TOKEN
        self.base_url = "https://api.github.com"
        self.headers = {
            "Authorization": f"Bearer {self.token}",
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28"
        }
    
    @staticmethod
    def parse_repo_url(repo_url: str) -> Tuple[str, str]:
        """
        Parse GitHub repo URL to extract owner and repo name.
        
        Supports formats:
        - https://github.com/owner/repo
        - https://github.com/owner/repo.git
        - git@github.com:owner/repo.git
        """
        repo_url = repo_url.strip().rstrip("/")
        
        # SSH format
        if repo_url.startswith("git@"):
            match = re.match(r"git@github\.com:(.+)/(.+?)(?:\.git)?$", repo_url)
            if match:
                return match.group(1), match.group(2)
        
        # HTTPS format
        parts = repo_url.split("/")
        owner = parts[-2]
        repo = parts[-1].replace(".git", "")
        return owner, repo
    
    async def get_default_branch(self, owner: str, repo: str) -> str:
        """Get the default branch of a repository."""
        async with httpx.AsyncClient() as client:
            response = await client.get(
                f"{self.base_url}/repos/{owner}/{repo}",
                headers=self.headers
            )
            
            if response.status_code == 200:
                return response.json().get("default_branch", "main")
            
            return "main"  # fallback
    
    async def create_pull_request(
        self,
        owner: str,
        repo: str,
        head_branch: str,
        base_branch: Optional[str] = None,
        title: str = "[AI-AGENT] Automated Fix PR",
        body: str = "This PR was automatically generated by the Autonomous DevOps Agent."
    ) -> PRResult:
        """
        Create a pull request on GitHub.
        
        Args:
            owner: Repository owner
            repo: Repository name
            head_branch: Source branch with changes
            base_branch: Target branch (auto-detected if None)
            title: PR title
            body: PR description
        
        Returns:
            PRResult with success status and PR details
        """
        if not self.token:
            return PRResult(success=False, error="GitHub token not configured")
        
        # Auto-detect base branch if not provided
        if not base_branch:
            base_branch = await self.get_default_branch(owner, repo)
        
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls"
        
        data = {
            "title": title,
            "body": body,
            "head": head_branch,
            "base": base_branch
        }
        
        async with httpx.AsyncClient() as client:
            response = await client.post(url, json=data, headers=self.headers)
            
            if response.status_code == 201:
                pr_data = response.json()
                return PRResult(
                    success=True,
                    pr_number=pr_data["number"],
                    pr_url=pr_data["html_url"]
                )
            elif response.status_code == 422:
                # PR might already exist or validation error
                error_data = response.json()
                errors = error_data.get("errors", [])
                if errors and "pull request already exists" in str(errors).lower():
                    # Try to find existing PR
                    existing = await self._find_existing_pr(owner, repo, head_branch, base_branch)
                    if existing:
                        return PRResult(
                            success=True,
                            pr_number=existing["number"],
                            pr_url=existing["html_url"]
                        )
                return PRResult(success=False, error=f"Validation error: {response.text}")
            else:
                return PRResult(success=False, error=f"API error: {response.status_code} - {response.text}")
    
    async def _find_existing_pr(
        self,
        owner: str,
        repo: str,
        head_branch: str,
        base_branch: str
    ) -> Optional[Dict]:
        """Find an existing PR for the given branches."""
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls"
        params = {
            "head": f"{owner}:{head_branch}",
            "base": base_branch,
            "state": "open"
        }
        
        async with httpx.AsyncClient() as client:
            response = await client.get(url, params=params, headers=self.headers)
            
            if response.status_code == 200:
                prs = response.json()
                if prs:
                    return prs[0]
        
        return None
    
    async def get_latest_workflow_run(
        self,
        owner: str,
        repo: str,
        branch: str
    ) -> Optional[Dict]:
        """
        Get the latest workflow run for a branch.
        
        Returns the most recent workflow run data or None.
        """
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runs"
        params = {"branch": branch, "per_page": 5}
        
        async with httpx.AsyncClient() as client:
            response = await client.get(url, params=params, headers=self.headers)
            
            if response.status_code == 200:
                runs = response.json().get("workflow_runs", [])
                if runs:
                    return runs[0]  # latest run
        
        return None
    
    async def monitor_ci(
        self,
        owner: str,
        repo: str,
        branch: str,
        timeout: int = 300,
        poll_interval: int = 15
    ) -> CIResult:
        """
        Monitor CI workflow until completion.
        
        Args:
            owner: Repository owner
            repo: Repository name
            branch: Branch to monitor
            timeout: Maximum time to wait (seconds)
            poll_interval: Time between polls (seconds)
        
        Returns:
            CIResult with final status
        """
        if not self.token:
            return CIResult(status=CIStatus.ERROR, error="GitHub token not configured")
        
        start_time = time.time()
        last_run_id = None
        
        while time.time() - start_time < timeout:
            run = await self.get_latest_workflow_run(owner, repo, branch)
            
            if run:
                run_id = run["id"]
                status = run["status"]
                conclusion = run.get("conclusion")
                run_url = run["html_url"]
                
                # Only consider runs that started after our push
                if last_run_id is None or run_id >= last_run_id:
                    last_run_id = run_id
                    
                    if status == "completed":
                        if conclusion == "success":
                            return CIResult(
                                status=CIStatus.SUCCESS,
                                conclusion=conclusion,
                                run_url=run_url
                            )
                        else:
                            return CIResult(
                                status=CIStatus.FAILURE,
                                conclusion=conclusion,
                                run_url=run_url
                            )
                    elif status == "in_progress" or status == "queued":
                        # Still running
                        pass
            
            await asyncio.sleep(poll_interval)
        
        return CIResult(status=CIStatus.TIMEOUT, error="CI monitoring timed out")
    
    async def merge_pull_request(
        self,
        owner: str,
        repo: str,
        pull_number: int,
        merge_method: str = "squash"
    ) -> bool:
        """
        Merge a pull request.
        
        Args:
            owner: Repository owner
            repo: Repository name
            pull_number: PR number to merge
            merge_method: Merge method (merge, squash, rebase)
        
        Returns:
            True if merge successful
        """
        if not self.token:
            return False
        
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}/merge"
        
        data = {
            "merge_method": merge_method,
            "commit_title": f"[AI-AGENT] Auto-merge PR #{pull_number}"
        }
        
        async with httpx.AsyncClient() as client:
            response = await client.put(url, json=data, headers=self.headers)
            return response.status_code == 200
    
    async def handle_pr_and_ci(
        self,
        repo_url: str,
        branch_name: str,
        auto_merge: bool = True,
        ci_timeout: int = 300
    ) -> WorkflowResult:
        """
        Complete PR workflow: create PR, monitor CI, and optionally merge.
        
        This is the main integration point for the agent.
        
        Args:
            repo_url: GitHub repository URL
            branch_name: Branch with AI fixes
            auto_merge: Whether to auto-merge on CI success
            ci_timeout: Max time to wait for CI
        
        Returns:
            WorkflowResult with complete status
        """
        owner, repo = self.parse_repo_url(repo_url)
        
        # 1. Create PR
        pr_result = await self.create_pull_request(owner, repo, branch_name)
        
        if not pr_result.success:
            return WorkflowResult(
                pr_created=False,
                error=pr_result.error
            )
        
        # 2. Monitor CI (async - will be polled separately)
        # Return immediately with PR info, CI will be monitored in background
        return WorkflowResult(
            pr_created=True,
            pr_url=pr_result.pr_url,
            pr_number=pr_result.pr_number,
            ci_status=CIStatus.PENDING
        )
    
    async def poll_ci_and_merge(
        self,
        repo_url: str,
        branch_name: str,
        pr_number: int,
        auto_merge: bool = True,
        ci_timeout: int = 300
    ) -> WorkflowResult:
        """
        Poll CI status and merge if successful.
        
        This is called asynchronously after PR creation.
        """
        owner, repo = self.parse_repo_url(repo_url)
        
        # Monitor CI
        ci_result = await self.monitor_ci(owner, repo, branch_name, timeout=ci_timeout)
        
        result = WorkflowResult(
            pr_created=True,
            pr_number=pr_number,
            ci_status=ci_result.status,
            ci_url=ci_result.run_url
        )
        
        # Auto-merge if CI passed and enabled
        if auto_merge and ci_result.status == CIStatus.SUCCESS:
            merged = await self.merge_pull_request(owner, repo, pr_number)
            result.merged = merged
        
        return result
    
    async def get_pr_status(self, owner: str, repo: str, pr_number: int) -> Dict[str, Any]:
        """Get current PR status including CI checks."""
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pr_number}"
        
        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=self.headers)
            
            if response.status_code == 200:
                pr = response.json()
                return {
                    "state": pr["state"],
                    "merged": pr["merged"],
                    "mergeable": pr["mergeable"],
                    "html_url": pr["html_url"]
                }
        
        return {}


# Singleton instance
github_service = GitHubService()
